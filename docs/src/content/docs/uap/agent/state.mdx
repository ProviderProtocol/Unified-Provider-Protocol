---
title: State Management
description: Functional state management with AgentState.
---

import { Aside, Badge, Card, CardGrid } from '@astrojs/starlight/components';

# State Management

<Badge text="UAP-1.0.0" variant="note" />

## AgentState Structure

`AgentState` is an immutable snapshot of agent execution state.

| Field | Type | Description |
|-------|------|-------------|
| `id` | String | State snapshot ID (UUIDv4) |
| `messages` | List&lt;Message&gt; | Conversation history (UPP Messages) |
| `step` | Integer | Current step number |
| `metadata` | Map | User-defined metadata |
| `reasoning` | List&lt;String&gt; | Reasoning traces (for ReAct) |
| `plan` | List&lt;PlanStep&gt;? | Execution plan (for Plan strategy) |

## State Operations

All state operations return new state instances:

```text
interface AgentState {
  // Factory
  static initial() -> AgentState

  // Immutable operations - all return new AgentState
  withMessage(message: Message) -> AgentState
  withMessages(messages: List&lt;Message&gt;) -> AgentState
  withContext(messages: List&lt;Message&gt;) -> AgentState
  withStep(step: Integer) -> AgentState
  withMetadata(key: String, value: Any) -> AgentState
  withReasoning(reasoning: String) -> AgentState
  withPlan(plan: List&lt;PlanStep&gt;) -> AgentState

  // Serialization
  toJSON() -> AgentStateJSON
  static fromJSON(json: AgentStateJSON) -> AgentState
}
```

**Message Operations:**

- `withMessage(message)` — Appends a single message to history
- `withMessages(messages)` — Appends multiple messages to history
- `withContext(messages)` — **Replaces** entire message history

The distinction between `withMessages` and `withContext` is critical:

```text
state = AgentState.initial()
  .withMessage(UserMessage("Hello"))
  .withMessage(AssistantMessage("Hi"))

// Append: messages = [Hello, Hi, Goodbye]
state.withMessages([UserMessage("Goodbye")])

// Replace: messages = [Fresh start]
state.withContext([UserMessage("Fresh start")])
```

**Context Window Management:**

`withContext(messages)` enables context window management via middleware. UAP does not provide token estimation or model limits—developers are responsible for their model's constraints.

**Pattern 1: Prune Old Tool Outputs**

Tool outputs (file reads, command results) consume significant tokens and become stale. Prune them while protecting recent context:

```text
pruneToolOutputs: Middleware = {
  name: "prune-tool-outputs",

  before: async (ctx) => {
    // Simple token estimation: ~4 chars per token
    estimate = (msg) => JSON.stringify(msg).length / 4
    total = sum(ctx.state.messages.map(estimate))

    // Model-specific limit (developer knows their model)
    CONTEXT_LIMIT = 200000
    OUTPUT_RESERVE = 16000
    PROTECT_RECENT = 40000

    usable = CONTEXT_LIMIT - OUTPUT_RESERVE
    if (total <= usable) return ctx

    // Scan backwards, protect recent tokens, prune old tool outputs
    messages = [...ctx.state.messages]
    protected = 0

    for (i = messages.length - 1; i >= 0; i--) {
      msg = messages[i]
      msgTokens = estimate(msg)
      protected += msgTokens

      if (protected > PROTECT_RECENT && isToolResultMessage(msg)) {
        // Replace tool output with placeholder
        messages[i] = ToolResultMessage([{
          toolCallId: msg.results[0].toolCallId,
          result: "[Output cleared - context limit]"
        }])
      }
    }

    return { ...ctx, state: ctx.state.withContext(messages) }
  },
}
```

**Pattern 2: Sliding Window**

Keep only the N most recent messages:

```text
slidingWindow: Middleware = {
  name: "sliding-window",

  before: async (ctx) => {
    MAX_MESSAGES = 50
    messages = ctx.state.messages

    if (messages.length <= MAX_MESSAGES) return ctx

    // Keep most recent, ensuring we don't split user/assistant pairs
    truncated = messages.slice(-MAX_MESSAGES)
    return { ...ctx, state: ctx.state.withContext(truncated) }
  },
}
```

**Pattern 3: Summarize Old Context**

Use a smaller model to summarize old conversation before discarding:

```text
summarizeOldContext: Middleware = {
  name: "summarize-context",

  // Summarizer LLM passed at construction
  init: (summarizerLLM) => ({
    before: async (ctx) => {
      estimate = (msg) => JSON.stringify(msg).length / 4
      total = sum(ctx.state.messages.map(estimate))

      THRESHOLD = 150000
      KEEP_RECENT = 10

      if (total <= THRESHOLD) return ctx

      messages = ctx.state.messages
      old = messages.slice(0, -KEEP_RECENT)
      recent = messages.slice(-KEEP_RECENT)

      // Generate summary of old context
      summary = await summarizerLLM.query(
        "Summarize this conversation, preserving key facts:\n" +
        old.map(m => JSON.stringify(m)).join("\n")
      )

      // Replace with summary + recent messages
      return {
        ...ctx,
        state: ctx.state.withContext([
          UserMessage("[Previous conversation summary]\n" + summary.response.text),
          ...recent
        ])
      }
    },
  }),
}

// Usage
agent({
  middleware: [
    summarizeOldContext.init(
      llm({ model: anthropic("claude-3-5-haiku-latest"), params: { max_tokens: 500 } })
    ),
  ],
})
```

**Composing Strategies:**

Middleware composes naturally—apply multiple strategies in order:

```text
agent({
  middleware: [
    pruneToolOutputs(),      // First: clear stale tool outputs
    slidingWindow(100),      // Then: cap message count
    summarizeIfNeeded(llm),  // Finally: summarize if still over
  ],
})
```

## State Flow Example

```text
// Initialize
s0 = AgentState.initial()
// s0 = { id: "uuid-1", messages: [], step: 0, metadata: {}, reasoning: [] }

// First interaction
{ turn: t1, state: s1 } = await agent.generate("Hello", s0)
// s1 = { id: "uuid-2", messages: [...t1.messages], step: 1, ... }

// s0 is unchanged - can branch
{ turn: t2a, state: s2a } = await agent.generate("Option A", s0)
{ turn: t2b, state: s2b } = await agent.generate("Option B", s0)

// Continue from s1
{ turn: t2, state: s2 } = await agent.generate("Continue", s1)

// Inspect any state at any time
print(s0.messages)  // []
print(s1.messages)  // [user, assistant from t1]
print(s2.messages)  // [user, assistant from t1, user, assistant from t2]
```

## State Serialization

State serializes to JSON for persistence:

```text
// Save state
json = state.toJSON()
await storage.save(`state:${state.id}`, JSON.stringify(json))

// Restore state
saved = JSON.parse(await storage.load(`state:${state.id}`))
restored = AgentState.fromJSON(saved)

// Continue from restored state
{ turn, state: newState } = await agent.generate("Continue", restored)
```

## MUST Requirements for State

1. `AgentState` MUST be immutable—operations return new instances
2. State operations MUST NOT mutate the original state
3. Each state MUST have a unique ID
4. State MUST be fully serializable via `toJSON()`
5. `fromJSON()` MUST restore exact state